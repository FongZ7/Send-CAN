enum class ControllerState {
  INACTIVE,     // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
  REMOTE_ACTIVE, // ‡∏£‡∏µ‡πÇ‡∏°‡∏ó‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
  JOYSTICK_ACTIVE // ‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
};

// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤
ControllerState currentControllerState = ControllerState::INACTIVE;
ControllerState lastActiveState = ControllerState::INACTIVE;
unsigned long emergencyStopTime = 0;
unsigned long lastControllerActivityTime = 0;
const unsigned long CONTROLLER_TIMEOUT = 15000;     // ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡πá‡∏ô 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
const unsigned long INACTIVITY_TIMEOUT = 2000;      // ‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏•‡∏±‡∏ö 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
const unsigned long WARNING_INTERVAL = 5000;        // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ global ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
const unsigned long ACTIVITY_CHECK_INTERVAL = 100; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 100ms
unsigned long lastActivityCheck = 0;
const unsigned long REMOTE_ACTIVITY_TIMEOUT = 2000; // 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏£‡∏µ‡πÇ‡∏°‡∏ó‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
static unsigned long lastRemoteSignalTime = 0;

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
void checkControllerActivity() {
  if (emergencyStopActive) {
      return;
  }

  unsigned long currentTime = millis();
  static unsigned long lastWarningTime = 0;

  if (currentTime - lastActivityCheck < ACTIVITY_CHECK_INTERVAL) {
      return;
  }
  lastActivityCheck = currentTime;

  if (currentControllerState != ControllerState::INACTIVE) {
      unsigned long elapsedTime = currentTime - lastControllerActivityTime;
      
      if (elapsedTime >= CONTROLLER_TIMEOUT) {
          currentControllerState = ControllerState::INACTIVE;
          stopAllMotors();
          digitalWrite(LED_Status_Can_Remote, HIGH);
          digitalWrite(LED_Status_Can_Joystick, HIGH);
          mySerial.println("‚è±Ô∏è ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
          mySerial.println("‚≠ï ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÉ‡∏î‡∏Å‡πá‡πÑ‡∏î‡πâ");
      } else if (currentTime - lastWarningTime >= WARNING_INTERVAL) {
          lastWarningTime = currentTime;
          unsigned long timeRemaining = (CONTROLLER_TIMEOUT - elapsedTime) / 1000;
          mySerial.println("‚è≥ ‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠: " + String(timeRemaining) + " ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ");
          if (timeRemaining <= 5) {
              mySerial.println("‚ö†Ô∏è ‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô!");
          }
      }
  }
}


bool handleControllerSelection(bool isRemote, uint8_t buttonByte, uint8_t movement1 = 0, uint8_t movement2 = 0) {
  unsigned long currentTime = millis();
  static unsigned long lastMessageTime = 0;
  const unsigned long MESSAGE_INTERVAL = 1000;

  if (emergencyStopActive) {
      return false;
  }

  bool hasActivity = (buttonByte != 0) || (movement1 != 0) || (movement2 != 0);

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏µ‡πÇ‡∏°‡∏ó
  if (isRemote && hasActivity) {
      lastRemoteSignalTime = currentTime;
  }

  // ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÉ‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
  if (currentControllerState == ControllerState::INACTIVE) {
      if (hasActivity) {
          currentControllerState = isRemote ? 
              ControllerState::REMOTE_ACTIVE : 
              ControllerState::JOYSTICK_ACTIVE;
          lastControllerActivityTime = currentTime;
          
          digitalWrite(LED_Status_Can_Remote, isRemote ? LOW : HIGH);
          digitalWrite(LED_Status_Can_Joystick, isRemote ? HIGH : LOW);
          
          mySerial.println(isRemote ? "üéÆ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏µ‡πÇ‡∏°‡∏ó" : "üïπÔ∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å");
          return true;
      }
      return false;
  }

  bool isCurrentDevice = (isRemote && currentControllerState == ControllerState::REMOTE_ACTIVE) ||
                       (!isRemote && currentControllerState == ControllerState::JOYSTICK_ACTIVE);

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
  if (isCurrentDevice && hasActivity) {
      lastControllerActivityTime = currentTime;
      return true;
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏•‡∏±‡∏ö‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
  if (!isCurrentDevice && hasActivity) {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ô‡∏≤‡∏ô‡∏û‡∏≠‡πÅ‡∏•‡πâ‡∏ß
      if (currentTime - lastControllerActivityTime >= INACTIVITY_TIMEOUT) {
          currentControllerState = isRemote ? 
              ControllerState::REMOTE_ACTIVE : 
              ControllerState::JOYSTICK_ACTIVE;
          lastControllerActivityTime = currentTime;
          
          stopAllMotors();
          digitalWrite(LED_Status_Can_Remote, isRemote ? LOW : HIGH);
          digitalWrite(LED_Status_Can_Joystick, isRemote ? HIGH : LOW);
          
          mySerial.println(isRemote ? "üîÑ ‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏£‡∏µ‡πÇ‡∏°‡∏ó" : "üîÑ ‡∏™‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å");
          return true;
      } else if (currentTime - lastMessageTime >= MESSAGE_INTERVAL) {
          lastMessageTime = currentTime;
          mySerial.println(isRemote ? 
              "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏£‡∏µ‡πÇ‡∏°‡∏ó‡πÑ‡∏î‡πâ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ" : 
              "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å‡πÑ‡∏î‡πâ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ");
          unsigned long remainingTime = (INACTIVITY_TIMEOUT - (currentTime - lastControllerActivityTime)) / 1000;
          mySerial.println("‚è≥ ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏´‡∏¢‡∏∏‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏µ‡∏Å " + String(remainingTime) + " ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ");
      }
  }

  return isCurrentDevice;
}


void updateButtonStates(bool isRemote, uint8_t buttonByte) {
  if (isRemote) {
      remoteButtons.valve = (buttonByte & 0x04);
      remoteButtons.remote = (buttonByte & 0x08);
      remoteButtons.teach = (buttonByte & 0x40);
      remoteButtons.deploy = (buttonByte & 0x80);
      isRemoteActive = (buttonByte != 0);
  } else {
      joystickButtons.valve = (buttonByte & 0x01);
      joystickButtons.remote = (buttonByte & 0x02);
      joystickButtons.teach = (buttonByte & 0x04);
      joystickButtons.deploy = (buttonByte & 0x08);
      isJoystickActive = (buttonByte != 0);
  }
}
void processValveMotor(bool buttonPressed) {
  static bool lastValveState = false;
  unsigned long currentTime = millis();
  static unsigned long valveStartTime = 0;

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
  if (emergencyStopActive) { 
      return;
  }

  bool isActiveDevice = (isRemoteCommand && currentControllerState == ControllerState::REMOTE_ACTIVE) ||
                       (!isRemoteCommand && currentControllerState == ControllerState::JOYSTICK_ACTIVE);

  if (!isActiveDevice) {
      return;
  }

  // ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏ß‡∏≤‡∏•‡πå‡∏ß
  if (buttonPressed != lastValveState) {
      lastValveState = buttonPressed;
      valveStartTime = currentTime;

      if (buttonPressed) {
          mySerial.println("üîÑ ‡πÄ‡∏õ‡∏¥‡∏î‡∏ß‡∏≤‡∏•‡πå‡∏ß");
          digitalWrite(MOTOR4_DIR_PIN, HIGH);
          analogWrite(MOTOR4_PWM_PIN, 255);
          valveState = true;
      } else {
          mySerial.println("‚Ü© ‡∏õ‡∏¥‡∏î‡∏ß‡∏≤‡∏•‡πå‡∏ß");
          digitalWrite(MOTOR4_DIR_PIN, LOW);
          analogWrite(MOTOR4_PWM_PIN, 255);
          valveState = false;
      }
      motorActive = true;
      lastControllerActivityTime = currentTime; // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
  }

  // ‡∏´‡∏¢‡∏∏‡∏î‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤
  if (motorActive && (currentTime - valveStartTime >= motorRunTime)) {
      analogWrite(MOTOR4_PWM_PIN, 0);
      motorActive = false;
      mySerial.println("‚èπ ‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ß‡∏≤‡∏•‡πå‡∏ß‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");
  }
}

void processJoystick(uint8_t msb, uint8_t byte2, uint8_t byte3, uint8_t byte4, uint8_t byte6, uint8_t byte7) {

  String horizontal = "";
  String vertical = "";
  String special1 = "";

  updateButtonStates(false, byte7);
  if (!handleControllerSelection(false, byte7, byte2, byte4)) {
    return;
}
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏î Emergency Stop
  if (emergencyStopActive) {
    stopAllMotors();
    updateCANIndicator();
    return;
}

isRemoteCommand = false;

lastControllerActivityTime = millis();

processValveMotor(byte7 == 1);
  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
  if (msb == 4 || msb == 132) horizontal = "L(" + String(byte2) + ")";           // ‡∏ã‡πâ‡∏≤‡∏¢
  else if (msb == 16 || msb == 144) horizontal = "R(" + String(byte2) + ")";  // ‡∏Ç‡∏ß‡∏≤

  if (byte3 == 16 || byte3 == 144) vertical = "U(" + String(byte4) + ")";   // ‡∏Ç‡∏∂‡πâ‡∏ô
  else if (byte3 == 4 || byte3 == 132) vertical = "D(" + String(byte4) + ")";  // ‡∏•‡∏á

  if (byte6 == 16) special1 = "üîµ";          // ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô
  else if (byte6 == 64) special1 = "üü£";  // ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏µ‡∏°‡πà‡∏ß‡∏á



  String movement = horizontal + vertical + special1;

  if (emergencyStopActive) {
    analogWrite(MOTOR1_PWM_PIN, 0);
    analogWrite(MOTOR2_PWM_PIN, 0);
    analogWrite(MOTOR3_PWM_PIN, 0);
    analogWrite(MOTOR4_PWM_PIN, 0);
    updateCANIndicator();
    return;  // Don't process any joystick commands if Emergency Stop is active
  }

  // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡πÅ‡∏•‡∏∞ PWM
  if (recording) {
    unsigned long currentTime = millis();
    if (currentTime - previousTime >= 50) {
      previousTime = currentTime;  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
      String pwmData = String(byte2) + "," + String(byte4);
      joystickSequence.push_back(String(currentTime) + "|" + movement + " PWM: " + pwmData);

    }
  }


  if (recording && movement.length() > 0) {
    mySerial.print("Recording: ");
    mySerial.println(movement);
  }

  // ‡∏õ‡∏£‡∏¥‡πâ‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞ PWM ‡πÅ‡∏ö‡∏ö‡∏õ‡∏Å‡∏ï‡∏¥‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
  if (!recording && !replaying && movement.length() > 0) {
    mySerial.print("Joystick Movement: ");
    mySerial.println(movement);
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡πÅ‡∏•‡∏∞ PWM
  if (movement.length() > 0) {
      lastMovementTime = millis();  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
  }


  if (byte6 == 16) {  // üîµ ‡∏õ‡∏∏‡πà‡∏°‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô ‚Üí ‡∏´‡∏°‡∏∏‡∏ô‡∏ã‡πâ‡∏≤‡∏¢
    mySerial.println("Motor 3 Direction: Left");
    digitalWrite(MOTOR3_DIR_PIN, LOW);
    analogWrite(MOTOR3_PWM_PIN, 200);  

  } else if (byte6 == 64) {  // üü£ ‡∏õ‡∏∏‡πà‡∏°‡∏°‡πà‡∏ß‡∏á ‚Üí ‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏ß‡∏≤
    mySerial.println("Motor 3 Direction: Right");
    digitalWrite(MOTOR3_DIR_PIN, HIGH);
    analogWrite(MOTOR3_PWM_PIN, 200);  

  } else {  // ‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏õ‡∏∏‡πà‡∏° ‚Üí ‡∏´‡∏¢‡∏∏‡∏î‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà 3
    analogWrite(MOTOR3_PWM_PIN, 0); 

  }


  // ‡∏™‡∏±‡πà‡∏á‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Ç‡∏≠‡∏á‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å
  if (!replaying) {
    if (byte2 > 0) {
      if (msb == 4 || msb == 132) {  // ‡∏ã‡πâ‡∏≤‡∏¢
        mySerial.println("Motor 1 Direction: Left");
        digitalWrite(MOTOR1_DIR_PIN, LOW);
        analogWrite(MOTOR1_PWM_PIN, byte2);  
        status_stop = 0;

        if (indexA > 0) {
          indexA--;  // ‡∏•‡∏î index (0-32)
          updateCANIndicator();
        }
     
      } else if (msb == 16 || msb == 144) {  // ‡∏Ç‡∏ß‡∏≤
        mySerial.println("Motor 1 Direction: Right");
        digitalWrite(MOTOR1_DIR_PIN, HIGH);
        analogWrite(MOTOR1_PWM_PIN, byte2);  
        status_stop = 0;

        if (indexA < MAX_INDEX_A){
         indexA++;  // ‡πÄ‡∏û‡∏¥‡πà‡∏° index (0-32)
          updateCANIndicator(); 
        } 
      }
    }


    if (byte4 > 0) {
      if (byte3 == 16 || byte3 == 144) {  // ‡∏Ç‡∏∂‡πâ‡∏ô
        mySerial.println("Motor 2 Direction: Up");
        digitalWrite(MOTOR2_DIR_PIN, HIGH);
        analogWrite(MOTOR2_PWM_PIN, byte4);  

        if (indexB < MAX_INDEX_B) {
          indexB++;  // ‡πÄ‡∏û‡∏¥‡πà‡∏° index (0-24)
        updateCANIndicator();
      }
        status_stop = 0;
      } else if (byte3 == 4 || byte3 == 132) {  // ‡∏•‡∏á
        mySerial.println("Motor 2 Direction: Down");
        digitalWrite(MOTOR2_DIR_PIN, LOW);
        analogWrite(MOTOR2_PWM_PIN, byte4);  

        if (indexB > 0) {
          indexB--;  // ‡∏•‡∏î index (0-24)
        updateCANIndicator();
        }
        
        status_stop = 0;
      }
    }
    
  }
}



void processRemoteMovement(uint8_t byte3, uint8_t byte4, uint8_t byte5) {
  // Vertical Movement (Motor 2)
  if (byte3 == 128) {
      analogWrite(MOTOR2_PWM_PIN, 0);
  } else if (byte3 < 128) {
      digitalWrite(MOTOR2_DIR_PIN, LOW);  // Down
      analogWrite(MOTOR2_PWM_PIN, map(byte3, 0, 128, 255, 0));
  } else {
      digitalWrite(MOTOR2_DIR_PIN, HIGH); // Up
      analogWrite(MOTOR2_PWM_PIN, map(byte3, 128, 255, 0, 255));
  }

  // Horizontal Movement (Motor 1)
  if (byte4 == 128) {
      analogWrite(MOTOR1_PWM_PIN, 0);
  } else if (byte4 < 128) {
      digitalWrite(MOTOR1_DIR_PIN, LOW);  // Left
      analogWrite(MOTOR1_PWM_PIN, map(byte4, 0, 128, 255, 0));
  } else {
      digitalWrite(MOTOR1_DIR_PIN, HIGH); // Right
      analogWrite(MOTOR1_PWM_PIN, map(byte4, 128, 255, 0, 255));
  }

  // Stream/Fog Control (Motor 3)
  if (byte5 >= 240) {
      digitalWrite(MOTOR3_DIR_PIN, HIGH); // Stream full
      analogWrite(MOTOR3_PWM_PIN, 255);
      mySerial.println("Stream: Full");
  } else if (byte5 <= 10) {
      digitalWrite(MOTOR3_DIR_PIN, LOW);  // Fog full
      analogWrite(MOTOR3_PWM_PIN, 255);
      mySerial.println("Fog: Full");
  } else if (byte5 > 128) {
      digitalWrite(MOTOR3_DIR_PIN, HIGH); // Stream variable
      analogWrite(MOTOR3_PWM_PIN, map(byte5, 129, 239, 180, 255));
      mySerial.println("Stream: " + String(map(byte5, 129, 239, 70, 100)) + "%");
  } else if (byte5 < 128) {
      digitalWrite(MOTOR3_DIR_PIN, LOW);  // Fog variable
      analogWrite(MOTOR3_PWM_PIN, map(byte5, 11, 127, 180, 255));
      mySerial.println("Fog: " + String(map(byte5, 11, 127, 70, 100)) + "%");
  } else {
      analogWrite(MOTOR3_PWM_PIN, 0);    // Stop
  }
}

void processRemote(CAN_message_t msg) {
  static uint8_t lastByte3 = 128;
  static uint8_t lastByte4 = 128;
  static uint8_t lastByte5 = 128;
  static bool lastValveState = false;
  static bool lastTeachButton = false;
  static unsigned long teachPressTime = 0;
  static unsigned long lastRemoteActivity = 0;
  const unsigned long REMOTE_TIMEOUT = 1000; // 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏õ‡∏¥‡∏î‡∏£‡∏µ‡πÇ‡∏°‡∏ó
  const unsigned long TEACH_HOLD_TIME = 100;

  unsigned long currentTime = millis();
  uint8_t byte1 = msg.buf[1];
  uint8_t byte2 = msg.buf[2];
  uint8_t byte3 = msg.buf[3];
  uint8_t byte4 = msg.buf[4];
  uint8_t byte5 = msg.buf[5];

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏à‡∏≤‡∏Å‡∏£‡∏µ‡πÇ‡∏°‡∏ó
  lastRemoteActivity = currentTime;

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Emergency Stop ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏µ‡πÇ‡∏°‡∏ó‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà
  if (currentControllerState == ControllerState::REMOTE_ACTIVE) {
      bool newEmergencyState = (byte1 & 0x01);
      if (newEmergencyState != emergencyStopActive) {
          emergencyStopActive = newEmergencyState;
          if (emergencyStopActive) {
              lastActiveState = currentControllerState;
              emergencyStopTime = currentTime;
              
              mySerial.println("Emergency Stop Activated!");
              processValveMotor(false);
              stopAllMotors();
              return;
          } else {
              emergencyStopActive = false;
              lastControllerActivityTime = currentTime;
              
              mySerial.println("Emergency Stop Released - System Ready");
              mySerial.println("üîÑ ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
              
              bool isRemote = (lastActiveState == ControllerState::REMOTE_ACTIVE);
              digitalWrite(LED_Status_Can_Remote, isRemote ? LOW : HIGH);
              digitalWrite(LED_Status_Can_Joystick, isRemote ? HIGH : LOW);
          }
      }
  }

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå
  updateButtonStates(true, byte1);
  if (!handleControllerSelection(true, byte1, byte3, byte4)) {
      return;
  }

  // Teach button handling
  bool teachButton = (byte1 & 0x40);
  
  // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°
  if (teachButton && !lastTeachButton) {
      teachPressTime = millis();
      
      // ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      if (remoteReplaying) {
          mySerial.println("‚èπ ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥‡πÅ‡∏•‡∏∞‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•");
          remoteReplaying = false;
          remoteSequence.clear();
          stopAllMotors();
      }
      // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥ ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥
      else if (!remoteRecording && !remoteReplaying && !remoteSequence.empty()) {
          mySerial.println("‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥");
          remoteReplaying = true;
          remoteReplayIndex = 0;
          remoteReplayStartTime = millis();
          remoteFirstRecordedTime = remoteSequence[0].substring(0, 
              remoteSequence[0].indexOf("|")).toInt();
      }
  }
  
  // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á
  if (teachButton && !remoteReplaying && 
      (millis() - teachPressTime > TEACH_HOLD_TIME)) {
      if (!remoteRecording) {
          mySerial.println("üìå ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å...");
          remoteRecording = true;
          remoteSequence.clear();
      }
      
      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
      String moveData = String(millis()) + "|" + 
                       String(byte3) + "," + 
                       String(byte4) + "," + 
                       String(byte5) + "," +
                       String(byte1 & 0x04);
      remoteSequence.push_back(moveData);
      mySerial.println("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å: " + moveData);
  }
  
  // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏õ‡∏∏‡πà‡∏°
  if (!teachButton && lastTeachButton && remoteRecording) {
      mySerial.println("‚úÖ ‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å");
      remoteRecording = false;
  }

  lastTeachButton = teachButton;

  // Valve Control
  bool valveOn = (byte1 & 0x04);
  if (valveOn != lastValveState) {
      isRemoteCommand = true; // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å remote
      processValveMotor(valveOn);
      mySerial.println(valveOn ? "Valve is ON." : "Valve is OFF.");
      lastValveState = valveOn;
  }
  

  // ‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà
  if (remoteReplaying && !remoteSequence.empty()) {
      unsigned long currentReplayTime = millis() - remoteReplayStartTime;
      String command = remoteSequence[remoteReplayIndex];
      
      int delimiterIndex = command.indexOf("|");
      unsigned long recordedTime = command.substring(0, delimiterIndex).toInt();
      recordedTime -= remoteFirstRecordedTime;

      if (currentReplayTime >= recordedTime) {
          String data = command.substring(delimiterIndex + 1);
          int comma1 = data.indexOf(",");
          int comma2 = data.indexOf(",", comma1 + 1);
          int comma3 = data.indexOf(",", comma2 + 1);
          
          uint8_t replayByte3 = data.substring(0, comma1).toInt();
          uint8_t replayByte4 = data.substring(comma1 + 1, comma2).toInt();
          uint8_t replayByte5 = data.substring(comma2 + 1, comma3).toInt();
          bool replayValve = data.substring(comma3 + 1).toInt() == 1;

          processValveMotor(replayValve);
          processRemoteMovement(replayByte3, replayByte4, replayByte5);
          mySerial.println("‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥: " + data);
          
          remoteReplayIndex++;
          if (remoteReplayIndex >= remoteSequence.size()) {
              remoteReplayIndex = 0;
              remoteReplayStartTime = millis();
          }
      }
  }

  // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏Å‡∏ï‡∏¥
  if (!remoteReplaying && !remoteRecording) {
      processRemoteMovement(byte3, byte4, byte5);
  }

  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
  if (byte3 != lastByte3 || byte4 != lastByte4 || byte5 != lastByte5) {
      String h = (byte4 < 128) ? "L(" + String(byte4) + ")" :
                (byte4 > 128) ? "R(" + String(byte4) + ")" : "M(128)";
      String v = (byte3 < 128) ? "D(" + String(byte3) + ")" :
                (byte3 > 128) ? "U(" + String(byte3) + ")" : "M(128)";
      String f = "";
      
      if (byte5 >= 240) f = " Stream:Full";
      else if (byte5 <= 10) f = " Fog:Full";
      else if (byte5 > 128) f = " Stream:" + String(map(byte5, 129, 239, 70, 100)) + "%";
      else if (byte5 < 128) f = " Fog:" + String(map(byte5, 11, 127, 70, 100)) + "%";
      else f = " Stream/Fog:Stop";
      
      mySerial.print("Remote Control Movement: ");
      mySerial.println(h + v + f);
      
      lastByte3 = byte3;
      lastByte4 = byte4;
      lastByte5 = byte5;
  }
}



void loop()
{
  static unsigned long lastRemoteCheck = 0;
  const unsigned long REMOTE_CHECK_INTERVAL = 100;
  const unsigned long REMOTE_TIMEOUT = 1000;
  unsigned long currentTime = millis();

  checkControllerActivity();

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏µ‡πÇ‡∏°‡∏ó
  if (currentTime - lastRemoteCheck >= REMOTE_CHECK_INTERVAL) {
    lastRemoteCheck = currentTime;
    
    if (currentControllerState == ControllerState::REMOTE_ACTIVE &&
        currentTime - lastRemoteSignalTime > REMOTE_ACTIVITY_TIMEOUT) {
        currentControllerState = ControllerState::INACTIVE;
        emergencyStopActive = false;
        stopAllMotors();
        digitalWrite(LED_Status_Can_Remote, HIGH);
        digitalWrite(LED_Status_Can_Joystick, HIGH);
        mySerial.println("üì¢ ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏µ‡πÇ‡∏°‡∏ó‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢");
        mySerial.println("‚≠ï ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÉ‡∏´‡∏°‡πà");
    }
}

  //////////////////joystick///////////////////////////////////////
  if (Can.read(CAN_RX_msg)) {
    if (CAN_RX_msg.id == JOYSTICK_CAN_ID) {
      unsigned long currentTime2 = millis();
      if (currentTime2 - previousTime2 >= 50) {
        previousTime2 = currentTime2;  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        digitalToggle(LED_Status_Can_Joystick);
      }
        uint8_t msb = CAN_RX_msg.buf[0];         //‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤
        uint8_t byte2 = CAN_RX_msg.buf[1];       //‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå
        uint8_t byte3 = CAN_RX_msg.buf[2];       //‡∏Ç‡∏∂‡πâ‡∏ô‡∏•‡∏á
        uint8_t byte4 = CAN_RX_msg.buf[3];       //‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå
        uint8_t byte6 = CAN_RX_msg.buf[5];       //stream/fog
        uint8_t byte7 = CAN_RX_msg.buf[6];       //‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î‡∏ß‡∏≤‡∏•‡πå‡∏ß
        if (!emergencyStopActive) {
          processValveMotor(byte7 == 1);
          processJoystick(msb, byte2, byte3, byte4, byte6, byte7);
      }
     }

     ///////////////////////////Teach//////////////////////////////////
    if (CAN_RX_msg.id == SW_JOYSTICK_CAN_ID) {            // ‡∏õ‡∏∏‡πà‡∏°‡∏à‡∏≤‡∏Å joystick 6 ‡∏õ‡∏∏‡πà‡∏°
      uint8_t byteJT0 = CAN_RX_msg.buf[0];  // Teach
      uint8_t byteJT1 = CAN_RX_msg.buf[1];  // On/Off Valve
      uint8_t byteJT2 = CAN_RX_msg.buf[2];  // On/Off Remote
      uint8_t byteJT3 = CAN_RX_msg.buf[3];  // Spare1
      uint8_t byteJT4 = CAN_RX_msg.buf[4];  // Spare2
      uint8_t byteJT5 = CAN_RX_msg.buf[5];  // Deploy/STOW

      uint8_t combinedState = 0;
      if (byteJT0) combinedState |= 0x04; // Teach
      if (byteJT1) combinedState |= 0x01; // Valve
      if (byteJT2) combinedState |= 0x02; // Remote
      if (byteJT5) combinedState |= 0x08; // Deploy/Stow

       
    updateButtonStates(false, combinedState);
    
      
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å/‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥
      if (byteJT0 == 1 && lastButtonState == false) {
        if (replaying) {
          mySerial.println("‚èπ Stopping replay...");
          Status_CAN_JOYSTICK = true;
          replaying = false;
          joystickSequence.clear();  // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ
        } else {
          mySerial.println("üìå Start Recording...");
          // joystickSequence.clear();  // ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ
          recording = true;
        }
        status_stop = 0;
      }

      lastButtonState = (byteJT0 == 1);  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î

      // ‡∏´‡∏¢‡∏∏‡∏î‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥
      if (recording && byteJT0 == 0) {
        mySerial.println("‚úÖ Stop Recording. Start Replaying...");
        recording = false;
        replaying = true;
        Status_CAN_JOYSTICK = true;
        replayIndex = 0;
        lastReplayTime = millis();
        replayStartTime = millis();                                                                      // ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥
        firstRecordedTime = joystickSequence[0].substring(0, joystickSequence[0].indexOf("|")).toInt();  // ‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏£‡∏Å‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
      }
    }

    // **‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Å**
    if (replaying && !joystickSequence.empty()) {
      unsigned long currentReplayTime = millis() - replayStartTime;  // ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏õ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥
      String command = joystickSequence[replayIndex];

      // ‡∏î‡∏∂‡∏á timestamp ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏∞‡πÄ‡∏•‡πà‡∏ô
      int delimiterIndex = command.indexOf("|");
      unsigned long recordedTime = command.substring(0, delimiterIndex).toInt();
      recordedTime -= firstRecordedTime;  // ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà 0

      // ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ß‡πâ
      if (currentReplayTime >= recordedTime) {
        String movement = command.substring(delimiterIndex + 1);  // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
        mySerial.println("Replaying: " + movement);

        // ‡πÅ‡∏¢‡∏Å PWM
        int pwm1 = movement.substring(movement.indexOf("PWM:") + 5, movement.indexOf(",")).toInt();
        int pwm2 = movement.substring(movement.indexOf(",") + 1).toInt();

        if (movement.indexOf("L") >= 0) {
          mySerial.println("Motor 1 Direction: Left");
          digitalWrite(MOTOR1_DIR_PIN, LOW);
          analogWrite(MOTOR1_PWM_PIN, pwm1);  
          if (indexA > 0) indexA-=1;  // ‡∏•‡∏î index (0-32)
          updateCANIndicator();
        } else if (movement.indexOf("R") >= 0) {
          mySerial.println("Motor 1 Direction: Right");
          digitalWrite(MOTOR1_DIR_PIN, HIGH);
          analogWrite(MOTOR1_PWM_PIN, pwm1);  
          if (indexA < MAX_INDEX_A) indexA+=1;  // ‡πÄ‡∏û‡∏¥‡πà‡∏° index (0-32)
          updateCANIndicator();

        } else if (movement.indexOf("U") >= 0) {
          mySerial.println("Motor 2 Direction: Up");
          digitalWrite(MOTOR2_DIR_PIN, HIGH);
          analogWrite(MOTOR2_PWM_PIN, pwm2);  
          if (indexB < MAX_INDEX_B) indexB+=1;  // ‡πÄ‡∏û‡∏¥‡πà‡∏° index (0-24)
          updateCANIndicator();
        } else if (movement.indexOf("D") >= 0) {
          mySerial.println("Motor 2 Direction: Down");
          digitalWrite(MOTOR2_DIR_PIN, LOW);
          analogWrite(MOTOR2_PWM_PIN, pwm2);  
          if (indexB > 0) indexB-=1;  // ‡∏•‡∏î index (0-24)
          updateCANIndicator();
        } else {
          stopMotors();
        }
        
        replayIndex++;
        if (replayIndex >= joystickSequence.size()) {
          replayIndex = 0;             // ‡∏ß‡∏ô‡∏ã‡πâ‡∏≥‡∏à‡∏≤‡∏Å‡∏ï‡πâ‡∏ô
          replayStartTime = millis();  // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏ß‡∏ô
        }
      }
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
    if ((millis() - lastMovementTime > idleTime) && status_stop == 0) {
      stopMotors();  // ‡∏´‡∏¢‡∏∏‡∏î‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
      status_stop = 1;
    }
/////////////////////////////////teach////////////////////////////////////////


    if(Status_CAN_JOYSTICK && replaying){                             //  CAN Tansmitter  JOYSTICK callback
      CAN_TX_msg.id = (0x122);
      CAN_TX_msg.len = 8;
      CAN_TX_msg.buf[0] =  1;   // Teach led
      CAN_TX_msg.buf[1] =  0;   // On/Off Valve led
      CAN_TX_msg.buf[2] =  0;   // On/Off Remote led
      CAN_TX_msg.buf[3] =  0;   // Spare1 led
      CAN_TX_msg.buf[4] =  0;   // Spare2 led
      CAN_TX_msg.buf[5] =  0;   // Deploy/STOW led
      Can.write(CAN_TX_msg);
      Status_CAN_JOYSTICK = false;
    }else if(Status_CAN_JOYSTICK && !replaying){                             //  CAN Tansmitter  JOYSTICK callback
      CAN_TX_msg.id = (0x122);
      CAN_TX_msg.len = 8;
      CAN_TX_msg.buf[0] =  0;   // Teach led
      CAN_TX_msg.buf[1] =  0;   // On/Off Valve led
      CAN_TX_msg.buf[2] =  0;   // On/Off Remote led
      CAN_TX_msg.buf[3] =  0;   // Spare1 led
      CAN_TX_msg.buf[4] =  0;   // Spare2 led
      CAN_TX_msg.buf[5] =  0;   // Deploy/STOW led
      Can.write(CAN_TX_msg);
      Status_CAN_JOYSTICK = false;
    }


    if (CAN_RX_msg.id == INDICATOR_CAN_ID) {              //  CAN Recevier INDICATOR 
      unsigned long currentTime2 = millis();
      if (currentTime2 - previousTime2 >= 50) {
        previousTime2 = currentTime2;  //  biuk
        digitalToggle(LED_Status_Can_Indicator);
        lastControllerActivityTime = currentTime;
      }
    }
    if(Status_CAN_INDICATOR){                             //  CAN Tansmitter  INDICATOR callback
      CAN_TX_msg.id = (0x069);
      CAN_TX_msg.len = 8;
      CAN_TX_msg.buf[0] =  0;   // index gruopA 32 led
      CAN_TX_msg.buf[1] =  0;   // index gruopB 24 led
      Can.write(CAN_TX_msg);
    }



    if (CAN_RX_msg.id == REMOTE_CAN_ID) {  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô CAN ID ‡∏Ç‡∏≠‡∏á remote ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      unsigned long currentTime2 = millis();
      if (currentTime2 - previousTime2 >= 50) {
        previousTime2 = currentTime2;  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
        digitalToggle(LED_Status_Can_Remote);
      }
        // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å CAN_RX_msg.buf[] ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á processRemote
        uint8_t byte1 = CAN_RX_msg.buf[0];   // ‡∏Ñ‡πà‡∏≤ byte1 ‡∏à‡∏≤‡∏Å CAN message
        uint8_t byte3 = CAN_RX_msg.buf[2];   // ‡∏Ñ‡πà‡∏≤ byte3 ‡∏à‡∏≤‡∏Å CAN message
        uint8_t byte4 = CAN_RX_msg.buf[3];   // ‡∏Ñ‡πà‡∏≤ byte4 ‡∏à‡∏≤‡∏Å CAN message
        uint8_t byte5 = CAN_RX_msg.buf[4];   // ‡∏Ñ‡πà‡∏≤ byte5 ‡∏à‡∏≤‡∏Å CAN message
        lastControllerActivityTime = currentTime;
        processRemote(CAN_RX_msg);

    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó LED ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô loop()
    if (remoteRecording) {
      digitalWrite(LED_Status_Can_Remote, (millis() % 200) < 100);  // ‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö‡πÄ‡∏£‡πá‡∏ß
    } else if (remoteReplaying) {
      digitalWrite(LED_Status_Can_Remote, (millis() % 1000) < 500); // ‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö‡∏ä‡πâ‡∏≤
    }
    } else {
      digitalWrite(LED_Status_Can_Remote, LOW);  // ‡∏õ‡∏¥‡∏î LED ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏ã‡πâ‡∏≥

    }
  }
  delay(5);
}


